=================================================================================
PO设计模式： 测试对象和测试用例 分离。
        用例当中：没有元素定位，没有元素操作。  只有页面的行为调用。
        测试对象： 元素定位，页面行为。

TestCases,PageObjects,TestDatas,PageLocators

TestCases = PageObjects + TestDatas
                |
            PageLocators

分离测试数据：
    1）部分数据共用。
    2）方便维护。 修改测试数据
    3）环境切换：SIT - 预发布() - 生产

管理测试数据？？
1、excel管理 -
2、配置文件 -
3、yaml
4、python??

1、命名规范 - 文件命名/页面  XX_page_locs.py
2、业务层级 -
3、

自动化的用例设计原则(前置/步骤/后置 - 测试顺序)：
1）用例尽量保持独立性。 其它的用例成功失败，都不会影响本用例的执行。
   1）每一个用例，打开关闭浏览器。环境准备和清理工作。
   2）有必然业务：
   流程，5个角色。申请人 - 审批1 - 审批2 - 审批3 -审批4 - 1

2）用例尽量简单(太复杂的用例不做自动化)。 - 复杂用例 -拆成多个子用例实现。

3）正常场景。--主流程覆盖。
   异常场景 -- 繁琐/规律 -- 字段检验

4）稳定性优先。
    1) 脚本质量  1）等待  2）元素定位  3）尽量不依赖测试环境数据；4）前置当中用接口/数据库查询
    2）测试环境  网络/硬件性能/数据

5）尽量不依赖当前的测试环境数据。 (-- 前提条件可以自己创造。减少人为的参与。)


===========================万能验证码：hapi =================================
======================后台管理：http://120.78.128.25:8765/Admin/Index/main.html 用户:lemon7/lemonbest==============
1）了解业务，熟悉业务
2）写(设计)测试用例  -  前置？步骤？期望？ - 涉及了哪些页面？哪些功能？
3）转化成自动化用例
4) 测试帐号来讲：自动化专用的帐号。


========================  basepage ======================
针对pageobjects层进行优化。
1）等待。操作 =-- 重复/简化
2）日志。 -- 记录用例的执行过程。
3）实时捕获异常信息 --- 输入日志当中。
4）失败截图。

PO: TestCases = PageObjects ＋　ＴｅｓｔＤａｔａｓ
　　　　　　　　　　　｜｜
　　　　　　　　　页面的行为
　　　　　　　　　　　｜｜
ｓｅｌｅｎｉｍ：等待／查找／输入／点击／获取属性／获取文本

对selenium的基本api进行 二次封装。加上日志/截图/异常处理。


自动化测试框架，应该具备什么？ -- 稳定，通用
1）入口 - 启动文件 - main.py
2）日志/异常信息输出  报告/用例管理/筛选用例执行(unittest/pytest - python语版测试框架)       /可扩展/可配置化


================================
1) PO应用 -
2）PO细分层 +　用例设计
======  编写自动化用例  ==========PageObject,Locator,TestCase,TestDatas

=========  web自动化测试框架，应该提供的功能 ============= selenium框架
日志、失败截图、异常信息处理 ----
3）basepage -

=========   失败重运行/allure.... =================
pip install -U pytest

4）pytest - 替换unittest???
unittest可以干什么？断言/组合用例/用例前置后置/数据驱动/运行用例/套件上/生成报告/收集用例
应用场景：单元测试/开发自测/自动化用例。
代码版的用例？？ --

都是测试框架 --- unittest - 模板。 pytest --- 灵活

1) 表达用例的方式。  继承unittest.TestCase           函数/类
2) 断言               self.assertXXXX()          assert 表达式(True/False)
3) 前置后置           setup/teardown-class           ????
4) 收集用例          TestLoader/TestSuite         自动识别用例？- 特征识别-识别规则
                                                  1）目录 - 哪一个目录下开始搜索用例 - 在哪个目录下运行pytest命令
                                                  2）文件 - test_开头的py文件。或者以_test结尾的py文件。
                                                  3）函数 - test_开头的函数。或者以Test开头的类名下的test_的方法。
5) 运行               unittest.main()                  pytest.main()
6) 丰富的插件



3) 前置后置           setup/teardown-class           ????
   unittest: 固定的函数名称: setup,teardown,setupClass,teardownClass - 用例/测试类
               前置后置分开：setup表示前置 ，teardown表示后置
                   自动使用：继承unittest，重写setup,teardown.
                 与测试用例：前置和后置和测试用例都是一个测试类当中。
    用例要使用前置当中的变量: self.变量名。变为测试类的属性

   pytest:  fixture
            1) 没有固定的函数名称。- 自定义。
               问题：pytest怎么知道它是一个前置和后置？-- 标注函数。
               解决：函数名称前面加上：@pytest.fixture
                                     def setup():
                                        pass
            2) 前置后置不分开，写在一个函数里。
               问题：pytest怎么知道，哪些代码是前置，哪些代码是后置？
               解决：分割线：yeild
               @pytest.fixture
               def setup():
                  # 前置代码
                  yeild
                  # 后置代码

            3) 如何确定它作为夹心饼干，夹的是什么？测试用例？测试类？其它？
            解决：@pytest.fixture(scope=作用域)
                     def setup():
                        pass
            四个作用域：测试函数(function),测试类(class),模块(module),测试会话(session)
            定义的时候：就指定这个前置后置，它是可以夹什么的。

            4）不会与测试类绑定在一起。

            =========================== 调用 ===============================
            5）使用方式：哪个测试类/函数需要用到XX个前置后置，自己去调用。
                        调用的方式：
                           测试函数/类前面：
                           @pytest.mark.usefixtures("")
                           def test_aaaaa():
                                pass


            6） 测试用例，要使用 fixture前置当中的变量：
                1）定义fixture的时候，要返回变量： yield 返回值
                2）调用fixture的时候，使用返回的变量：将 fixture函数名称作为用例的参数。

            pytest当中，测试用例的参数有2种：1) fixture的返回值 , 2）未来讲ddt的参数


            7) 共享机制：conftest.py文件 --- 放所有需要共享的前置。
                  注意：文件名称固定。
                  1）不需要引入。 用例会自动去搜索。
                  2）支持层级化。